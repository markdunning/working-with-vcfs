---
title: "Working with VCF files"
author: "Mark Dunning"
date: "24 May 2016"
output: html_document
---

# Introduction

In this session we:-

- Demonstrate how to call germline variants for a bam file containing aligned reads
- Explain what a *vcf* file is
- Loading a *vcf* file into IGV
- Interrogating vcf files using Bioconductor
- Intersect sets of calls

## Calling SNVs

We will use the [freebayes](https://github.com/ekg/freebayes#readme) genotype caller for convenience. The main reasons for choosing this were:-

- freely-available with an open-source licence
- easy to run and minimal command-line parameters to specify
- gives reasonable results

`freebayes` is a command-line tool that you will need to run from the terminal. As with all command-line tools, we first need to make sure that we are located in the correct directory. Remember that we can *change directory* using the unix command `cd`.

```{}
cd ~/home/participant/Course_Materials/Day2/
```

`freebayes` has already been installed for you on your desktop machine (or in the *docker* image, if you are using that). However, we can make sure that `freebayes` is available by typing `freebayes` at the terminal. This will give a basic description, a version number, and information about how to cite the package (very important if you end-up using the tool to generate results for your paper). Adding the *parameter* `-h` will display more-detailed help about the tool and some examples of how to use it.

```{}
freebayes
freebayes -h
```

We are going to use `freebayes` to call SNVs on some *hapmap* samples. In order to make the SNV-calling run in a reasonable time, we are only considering reads aligned to chromosome 20 in this analysis. In the [Appendix](#appendix) you will see the commands used to create the bam files.

The minimal requirements to run `freebayes` (and why it is appealing for this practical!) are a reference genome and a `.bam` file. The `-f` parameter is used to specify the location of a reference genome in `.fasta` format. 

***Please don't run this next command*** 

```{}
freebayes -f ../ref_data/human_g1k_v37.fasta data/hapmap/NA12878.chr20.bam
```

If you did run that command, you would quickly see that the screen gets filled with lots of text. These are the calls that `freebayes` is making being printed to the screen (the standard output for some unix commands). If you find yourself in this situation, a swift press of `CTRL + C` should stop the tool from running.

What we need to do is *direct the output* to a file. We can call the output file anything we like, but it is advisable to make the name relatable to the name of the input. If we are in the situation of calling genotypes on many samples, with many different callers, then we want to be able to identify the processing used on each sample.

Although it is not mandatory, we give the output file the extension `.vcf`. The `.vcf` format is a commonly-adopted standard for variant calls, which we will look into detail now.

```{}
freebayes -f ../ref_data/human_g1k_v37.fasta ../data/hapmap/NA12878.chr20.bam > NA12878.chr20.freebayes.vcf
```

## Understanding the vcf format

The vcf format was initially developed by the [1000 Genomes Project](http://www.1000genomes.org/wiki/Analysis/vcf4.0), and ownership has been subsequently transferred to [Global Alliance for Genomics and Health Data Working group file format team](http://ga4gh.org/#/fileformats-team). The format can be used to represent information about all kinds of genomic variation. In this session we will just consider SNVs.

We don't require any specialised software to look at the contents of a vcf file. They *can* be opened in a bog-standard text editor. However, there are several tools that will make our lives easier! For now, navigate to the folder and right-click on `NA12878.chr20.freebayes.vcf`. Select the option to open with `gedit` (a common text editor for Ubuntu).


In a similar vein to the bam and sam files we saw earlier, the `.vcf` files contains many lines of header information.
```{r echo=FALSE,comment=NA}
cat(system("head NA12878.chr20.freebayes.vcf",intern=TRUE),sep="\n")

```


After many more lines of information, we finally get to the details of the actual calls themsevles. This part of the file is tab-delimited; with 10 columns for every call. The [vcf specification page](http://www.1000genomes.org/wiki/Analysis/vcf4.0) gives details of what should be contained in each column

- CHROM
- POS
- ID
- REF
- ALT
- QUAL
- FILTER
- INFO
- FORMAT
- NA12878

Shown here is the information about the first five calls

```{r echo=FALSE,comment=NA}
cat(system("grep -v '##' NA12878.chr20.freebayes.vcf | head -n5",intern = TRUE),sep = "\n")
```


The first seven columns should look consistent across different genotype callers. In this exercise we have not annotated against known variants, or applied any filtering, so the `ID` and `FILTER` columns are blank. In some `.vcf` files these columns might be populated with dbSNP IDs or flags such as `PASS` / `FAIL` respectively.

The contents of the `INFO` and `FORMAT` columns will depend on what variant caller has been used. The `INFO` column contains metrics and other information related to ***each variant call*** as a set of `KEY;VALUE` pairs. Each pair is separated by a `;` character. 

The `INFO` for the first variant reads as:-

`AB=0.454545;ABP=3.20771;AC=1;AF=0.5;AN=2;AO=5;CIGAR=1X;DP=11;DPB=11;DPRA=0;EPP=3.44459;EPPR=4.45795;GTI=0;.......`

which we can interpret as:- 

```{r echo=FALSE}
library(stringr)
info <- "AB=0.454545;ABP=3.20771;AC=1;AF=0.5;AN=2;AO=5;CIGAR=1X;DP=11;DPB=11;DPRA=0;EPP=3.44459;EPPR=4.45795;GTI=0;LEN=1;MEANALT=1;MQM=60;MQMR=60;NS=1;NUMALT=1;ODDS=21.8887;PAIRED=1;PAIREDR=1;PAO=0;PQA=0;PQR=0;PRO=0;QA=188;QR=245;RO=6;RPL=1;RPP=6.91895;RPPR=3.0103;RPR=4;RUN=1;SAF=2;SAP=3.44459;SAR=3;SRF=5;SRP=8.80089;SRR=1;TYPE=snp;technology.ILLUMINA=1"

tmp <- sapply(str_split(info, ";")[[1]],function(x) str_split(x, "="))
df <- t(do.call(cbind, tmp))
colnames(df) <- c("Key","Value")
knitr::kable(df[1:10,])

```


The meaning of each `KEY`  is given in the header for the `.vcf` file.

```{r echo=FALSE}
cat(system("grep 'ID=AB,' NA12878.chr20.freebayes.vcf | head -n1",intern=TRUE))
cat(system("grep 'ID=ABP,' NA12878.chr20.freebayes.vcf | head -n1",intern=TRUE))
cat(system("grep 'ID=AC,' NA12878.chr20.freebayes.vcf | head -n1",intern=TRUE))
cat(system("grep 'ID=AF,' NA12878.chr20.freebayes.vcf | head -n1",intern=TRUE))
cat(system("grep 'ID=AN,' NA12878.chr20.freebayes.vcf | head -n1",intern=TRUE))
cat(system("grep 'ID=AO,' NA12878.chr20.freebayes.vcf | head -n1",intern=TRUE))
cat(system("grep 'ID=CIGAR,' NA12878.chr20.freebayes.vcf | head -n1",intern=TRUE))
cat(system("grep 'ID=DP,' NA12878.chr20.freebayes.vcf | head -n1",intern=TRUE))
cat(system("grep 'ID=DPB,' NA12878.chr20.freebayes.vcf | head -n1",intern=TRUE))
cat(system("grep 'ID=DPRA,' NA12878.chr20.freebayes.vcf | head -n1",intern=TRUE))

```



The final column in the file describes the calls for the sample `NA12878`, which was the only sample that we called variants on. In the sample column (`NA12878`) for the first variant we see the entry 

(`0/1:11:11,5:6:245:5:188:-13.9693,0,-19.1141`). 

These are values separated by a `:` character and they are interpreted in the same order as dictated by the `FORMAT` column which is `GT:DP:DPR:RO:QR:AO:QA:GL`

```{r echo=FALSE}
gt <- "0/1:11:11,5:6:245:5:188:-13.9693,0,-19.1141"
ky <- "GT:DP:DPR:RO:QR:AO:QA:GL"
values <- unlist(str_split(gt, ":"))
keys <- unlist(str_split(ky, ":"))
desc <- c("Genotype","Read Depth","Number of observation for each allele","Reference allele observation count","Sum of quality of the reference observations","Alternate allele observation count","Sum of quality of the alternate observations","Genotype Likelihood, log10-scaled likelihoods of the data given the called genotype for each possible genotype generated from the reference and alternate alleles given the sample ploidy")
df <- data.frame(keys,values,desc)
colnames(df) <- c("Key", "Value","Description")
knitr::kable(df)
```


So for this particular variant, in the sample `NA12878` there is a genotype of `0\1` (heterozygous) and a depth of 11 etc.

To understand the vcf format better, we can use another mode of operation of `freebayes` which is to call genotypes on multiple samples simultaneously. We can also specify an exact region of the genome to call genotypes to speed-up the processing.

```{}
freebayes -f ../ref_data/human_g1k_v37.fasta --region 20:500000-800000 data/hapmap/NA12878.chr20.bam data/hapmap/NA12873.chr20.bam data/hapmap/NA12874.chr20.bam > combined.chr20.subset.freebayes.vcf

```

As before, we can look at the first five calls.

```{r echo=FALSE,comment=NA}
cat(system("grep -v '##' combined.chr20.subset.freebayes.vcf | head -n5",intern = TRUE),sep = "\n")
```

You should notice that we now have columns `NA12878`, `NA12873` and `NA12874` as we have called variants in three samples. 

One easy way of being able to visualise the calls is to use the IGV browser. Before we do this however, we can do some extra processing to make it easier to process the files. This series of commands will compress and index the vcf files (similar to how bam files are indexed to produce a `.bai` file). IGV would probably cope fine with reading such relatively-small files, but it is good to get into the habit of processing our files in this manner.

```{}

bgzip -c combined.chr20.subset.freebayes.vcf > combined.chr20.subset.freebayes.vcf.gz
tabix -p  vcf combined.chr20.subset.freebayes.vcf.gz

bgzip -c NA12878.chr20.freebayes.vcf > NA12878.chr20.freebayes.vcf.gz
tabix -p vcf NA12878.chr20.freebayes.vcf.gz

```

After running these commands, you should see that the files `combined.chr20.subset.freebayes.vcf.gz`, `combined.chr20.subset.freebayes.vcf.gz.tbi`, `NA12878.chr20.freebayes.vcf.gz` and `NA12878.chr20.freebayes.vcf.gz.tbi` have been created in your working directory.

These files can be viewing in IGV and as usual we can zoom-in and scroll along the genome. Each `.vcf` introduces two tracks into the IGV data panel; the first gives information about the variant, and the second is for sample-specific information.

******

### Exercise

- Load IGV
- Select the files `NA12878.chr20.freebayes.vcf.gz` and `combined.chr20.subset.freebayes.vcf.gz` from the `File -> Open` menu
- Navigate to `chr20:500,900-505,630`
- Verify that the same information from the `.vcf` is shown in IGV
- What do the light and dark blue rectangles in the sample-specific tracks refer to?
- What SNPs are shared between the different samples?
    + are any unique to a particular sample?

    
******

To dig-into these files further, we will use tools within Bioconductor. Our goal will be to find calls that are in common between different samples, and what SNPs occur within coding regions. For completeness, we note that other command-line tools can be used to perform these operations (the [bedtools](http://bedtools.readthedocs.io/en/latest/) suite for example). However, we should be reasonably comfortable with R by now and the package we use interacts nicely with the `GenomicRanges` concepts we discussed yesterday.

## Importing into Bioconductor

### Multi-sample example

The `VariantAnnotation` package allows `.vcf` files to be imported. The `readVcf` function can be used and requires the file of a vcf file. You also need to specify a genome name. As we have seen already with other Bioconductor objects, typing the name of the object will print a summary to the screen. In the case of a "`CollapsedVCF`" object this is very detailed

```{r message=FALSE}
library(VariantAnnotation)
hapmap.calls <- readVcf("combined.chr20.subset.freebayes.vcf","hg19")

```


```{r eval=FALSE}
hapmap.calls
```

The "header" information can be extracted using `header`. This will contain the definitions of all the per-genotype (`INFO`) and per-sample information stored in the file

```{r eval=FALSE}
header(hapmap.calls)
info(header(hapmap.calls))
geno(header(hapmap.calls))
```

```{r echo=FALSE}
info(header(hapmap.calls))[1:3,]
geno(header(hapmap.calls))[1:3,]
```

## `INFO`

As described above, the `INFO` column in a `.vcf` file gives per-variant metadata as a series of key-value pairs. We can interrogate these data using the `info` function, which returns a data-frame-like object. Consequently, we can use the `$` operator to select a particular column of interest.

The name of each row is derived from the genomic location and base-change for each variant. There are too many columns to go through in detail, so we will just describe a few that are likely to be common to different callers.

```{r eval=FALSE}
info(hapmap.calls)
```

```{r echo=FALSE}
info(hapmap.calls)[1:3,1:5]
```

`NS` represents the number of samples with data. We would expect this to be 3 in all cases. However, as we are dealing with low-coverage data there are some sites where data could not be observed for all samples.

```{r}
summary(info(hapmap.calls)$NS)
```

```{r eval=FALSE}
infoMat <- info(hapmap.calls)
infoMat[info(hapmap.calls)$NS==1,]
```

```{r echo=FALSE}
infoMat <- info(hapmap.calls)
infoMat[info(hapmap.calls)$NS==1,1:5]
```

`DP` gives the depth observed at each position, which is given to us in the form of a vector. By looking at the distribtion of the depths, we see some variants with extremely low coverage. Later-on, we will see how we can develop filters to remove unreliable calls from our dataset. Variants with low depth would seem to be a good candidate for exclusion.

```{r}
hist(infoMat$DP)
table(infoMat$DP)
```

The columns we have looked at, `DP` and `NS` have both returned vectors when we extract them from the data frame. However, this is not the case for all columns in the data frame.

In order for the format to be as flexible as possible, we have to allow for the possibility that more than one type of variant is observed at a particular location. Therefore, some of the columns are given as a "`list`" which allows us to have multiple entries for a particular column in some cases.

For example, the `TYPE` column simply denotes what type of variant is observed at each position:- snp, insertion, deletion or something else. 

```{r}
infoMat$TYPE
```

As this column is a `list` we have to use a function such as `lapply` to process each entry. For example, we can get the different types of variants found at each position by using `length` in conjunction with `lapply`:-

```{r}
numVars <- unlist(lapply(infoMat$TYPE,length))
table(numVars)
```


We can find a few records where more than one type of variant is found. You should see that some of the columns are broken down into different values for each of the variants observed.

```{r eval=FALSE}
infoMat[numVars>1,]
```

```{r echo=FALSE}
infoMat[numVars>1,][1:3,1:5]
```

```{r}
infoMat[numVars>1,][1,]
```


## Accessing genotypes

The called genotypes can be accessed using the `geno` function. Recall that in the `.vcf` file, we have one column of genotype information for each sample, with each column consisting of `key:value` pairs. Using `geno` we can access all the values for a particular keys and be able to compare across samples. For example, the called genotypes are accessed as follows:-

```{r}
geno(hapmap.calls)
head(geno(hapmap.calls)$GT)
```
Usually each entry is `0/0` for a homozygous reference, `0/1` for a heterozygous call and `1/1` for a homozyous alternate allele. An entry of `.` indicates a position where no call could be made due to insufficient data. Moreover, we can also find `0/2` and `1/2` in rare cases where a second alternative allele was found. With `table` we can tabulate the calls between one sample and another

```{r}
table(geno(hapmap.calls)$GT[,1])
table(geno(hapmap.calls)$GT[,2])
table(geno(hapmap.calls)$GT[,1], geno(hapmap.calls)$GT[,2])
```

A common way to visualise these overlaps is to use a *venn diagram*. We can generate the venn diagram using the `limma` package (a popular package for the analysis of microarray data). First of all we need to create a data frame containing `0`s or `1` (or equivalenly `TRUE` or `FALSE`) depending on whether a variant was called in each sample. We can do this by creating three separate vectors and combining into a data frame. 

```{r}
called.NA12878 <- geno(hapmap.calls)$GT[,1] != "0/0"
called.NA12873 <- geno(hapmap.calls)$GT[,2] != "0/0"
called.NA12874 <- geno(hapmap.calls)$GT[,3] != "0/0"

called <- data.frame(called.NA12878, called.NA12873,called.NA12874)
head(called)
head(geno(hapmap.calls)$GT)
```

*N.B* a more sophisticated method would to use an `apply` statement

```{r}
called2 <- apply(geno(hapmap.calls)$GT, 2,function(x) x !="0/0")
```

The `vennDiagram` function can now be used on the data frame we just created.

```{r}
limma::vennDiagram(called)
```

Suppose we wanted to know about positions that were called homozygous for the alternate allele in all samples. We can first create a *logical vector* that is `TRUE` only if all three columns of the `GT` data frame are `1/1`. With this vector we can create a new vcf object in `VariantAnnotation`

```{r}
all.hom <- which(geno(hapmap.calls)$GT[,1]=="1/1" & geno(hapmap.calls)$GT[,2]=="1/1" & geno(hapmap.calls)$GT[,3]=="1/1")
hapmap.calls.homs <- hapmap.calls[all.hom]
```

`VariantAnnotation` also has the capability to write an object as a `.vcf` file for further inspection.

```{r}
writeVcf(hapmap.calls.homs, filename = "hapmap.common.hom.vcf")
```


******

### Exercise

Find all the positions that were called as heterozyous in all samples

  - Create a new vcf object; say `hapmap.calls.hets`
  - Now remove all variants with a depth less than 20
  - Write the remaining variants as a vcf file

```{r echo=FALSE}
all.het <- which(geno(hapmap.calls)$GT[,1]=="0/1" & geno(hapmap.calls)$GT[,2]=="0/1" & geno(hapmap.calls)$GT[,3]=="0/1")
hapmap.calls.hets <- hapmap.calls[all.het]

depfilt <- which(info(hapmap.calls.hets)$DP>20)
hapmap.calls.hets.filt <- hapmap.calls.hets[depfilt]
writeVcf(hapmap.calls.hets.filt, filename = "hapmap.common.hets.filt.vcf")
```


******

### Case 2: Variant locations

In this next section we will see how we can overlap the calls we have made with other genomic features, such as the pre-built gene models that we saw yesterday.

For this section, we are going to use all calls made on chromosome 20 for a single sample; `NA12878`. As we discovered yesterday, it can be problematic trying to perform overlaps when the chromosome naming convention is not consistent between files. Consequently, we are going to rename our variants to the `UCSC` style from the start.

```{r}
NA12878.calls <- readVcf("NA12878.chr20.freebayes.vcf","hg19")
seqlevelsStyle(NA12878.calls) <- "UCSC"
NA12878.calls <- keepSeqlevels(NA12878.calls, "chr20")
```

The `rowRanges` function will retrieve the positions of our variants as a familiar `GRanges` object. Along with the usual positional information, we also get extra "metadata" (`mcols`) about the base-change, a quality-score from `freebayes` and a filter (which has not been applied in this case).

```{r}
NA12878.calls.ranges <- rowRanges(NA12878.calls)

```

```{r eval=FALSE}
NA12878.calls.ranges
```


```{r echo=FALSE}
NA12878.calls.ranges[1:3]
```


## Overlapping with genes

We saw yesterday how to retrieve the coordinates for all genes in a given organism and genome-build. For this example, we can again use the package `TxDb.Hsapiens.UCSC.hg19.knownGene`

```{r message=FALSE}
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene

```

******

### Exercise

Find all `NA12878` variants that have been called within the gene "PRND"

- this gene has an Entrez ID of "23627"
- HINT: recall the `exonsBy` function from yesterday....
- check your answer in IGV

```{r echo=FALSE}

```

******

## More-automated location of variants

With a bit of scripting it would be possible to *loop* through a series of gene locations and get locate which gene each variant is located within. However, there is a convenience function `locateVariants` that will do the hard work for us. It has flexibility to allow us to search for variants within coding, intergenic or other regions. For example, adding the `CodingVariants()`argument tells the function to look for variants within coding sequences. You can see the help for `locateVariants` (`?locateVariants`) for information on the various options.

As this function runs you should see some message sbout `select()' returned many:1 mapping between keys and columns`. This is because some variants might be located within multiple transcripts for the same gene.

```{r warning=FALSE}
locs <- locateVariants(NA12878.calls.ranges, txdb, CodingVariants())
```

```{r eval=FALSE}
locs
```

```{r echo=FALSE}
locs[1:3]
```

This annotation step has put *Entrez IDs*

```{r}
library(org.Hs.eg.db)
symbol <- select(org.Hs.eg.db, keys=mcols(locs)$GENEID, keytype = "ENTREZID", columns="SYMBOL")
head(symbol)
mcols(locs)$SYMBOL <- symbol[,2]
locs

```


If we want, we can locate all the variants with respect to the nearest feature (in the case of intergenic variants).  

```{r warning=FALSE, message=FALSE}
all.locs <- locateVariants(NA12878.calls.ranges, txdb, AllVariants())
```

```{r eval=FALSE}
all.locs
table(all.locs$LOCATION)
```

```{r echo=FALSE}
all.locs[1:4]
table(all.locs$LOCATION)
```


## Producing an output table

To recap, we have information in the following tables

- `NA12878.calls.ranges` which has locations, details of the base-changes and a quality-score for each variant
- A table of variants which occur in the coding region of genes; `locs`
- meta information about the quality of each call; `info(NA12878.calls)`

Our task now is to combine these into one data frame, which we can start by converting each component into a data frame. We don't need all the columns from the `NA12878.calls.ranges` object as we already have the genomic location in the `locs.df` data frame. Consequently we can extract the meta data only using the function `meta`.

```{r}
locs.df <- as.data.frame(locs)
dim(locs.df)
meta <- mcols(NA12878.calls.ranges)
head(meta)
dim(meta)
info.df <- info(NA12878.calls)
dim(info.df)
```

As not all variants are inside coding regions, the number of rows in `locs` is not the same as the total number of variants. However, the column `locs$QUERYID` gives an index that we can use to look-up the relevant rows in the complete set of calls. Below we show how the extract data fror the first five coding variants.

```{r}
locs.df[1:5,]
locs.df$QUERYID[1:5]
NA12878.calls.ranges[locs.df$QUERYID[1:5],]
```


******

### Exercise

Construct a data frame containing:-

- The `locs.df` data frame with details of all the coding variants
- The metadata from the ranges object in the `meta` data frame
- `INFO` columns `DP`, `NS`, `RO` and `AO` from `info.df`
    + or any other columns you think might be of interest
- Write this data frame to a tab-delimited text file

```{r echo=FALSE}

infoMat <- info(NA12878.calls)
query.ids <- locs.df$QUERYID
df <- data.frame(locs.df, meta[query.ids,], infoMat[query.ids,c("DP","NS", "RO","AO")])
head(df)
write.table(df, file="NA12878.chr20.coding.annotated.txt",sep="\t")
```


******


## Predicting Amino acid changes

Determining whether a change at a particular base will lead to a different amino acid can be performed using one of the many `BSgenome...` packages in Bioconductor. These packages provide a pre-built database of genome sequence for various organisms. They allow us to query particular regions of the genome and return the results in a `Biostrings`-compatible format. We have already seen that `Biostrings` allows us to perform various computations on DNA sequences; including the ability to translate DNA to RNA. 

There is a function, `predictCoding` that will do all the predictions for us. In order to make use of this function, we need to have loaded a pre-built genome in `Biostrings` format. There are many such packages listed on the bioconductor web page. The one we need is `BSgenome.Hsapiens.UCSC.hg19`

```{r}
library(BSgenome.Hsapiens.UCSC.hg19)
coding.pred <- predictCoding(NA12878.calls, txdb, seqSource=Hsapiens)
```

```{r eval=FALSE}
coding.pred 
table(coding.pred $CONSEQUENCE)
```

```{r echo=FALSE}
coding.pred [1:3]
table(coding.pred $CONSEQUENCE)
```

Probably the most interesting variants that cause a change in protein; which are called ***nonsynonymous***, or those that cause a *frameshift* or *nonsense* mutation

```{r}
coding.pred[coding.pred$CONSEQUENCE == "nonsense"]
coding.pred[coding.pred$CONSEQUENCE == "frameshift"]
```


## Summary

- We have used a common genotype caller `freebayes` to call SNVs from a set of healthy individuals
    + there are many paramters that can be tweaked
- The `.vcf` format contains a rich description of the called variants
- Bioconducor tools can be used to import and parse vcf files
- We can use `GenomicRanges` to overlap our calls with other genomic features of interest


# <a name="appendix"></a> Appendix

## Files used in session

Commands used to generate bam files for genotype calling

- First, get a copy of the reference genome from the 1000 genomes FTP site

```{}
wget ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/technical/reference/human_g1k_v37.fasta.gz -P ../ref_data/
gunzip ../ref_data/human_g1k_v37.fasta.gz

```

- We have already seen how `samtools` can be used to view aligned reads in `.bam` format. In fact, the `.bam` does not need to be stored locally on our desktop machine, and can be an FTP link. Here we `view` the remote link to the bam file and extract only the chromosome 22 reads. 

```{}
samtools view -h ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/technical/other_exome_alignments/NA19239/exome_alignment/NA19239.mapped.solid.mosaik.YRI.exome.20111114.bam 22 | samtools view -bS - > data/hapmap/NA19239.chr22.bam
samtools index data/hapmap/NA19239.chr22.bam

```

```{}
samtools view -h ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/technical/other_exome_alignments/NA19238/exome_alignment/NA19238.mapped.illumina.mosaik.YRI.exome.20111114.bam 22 | samtools view -bS - > data/hapmap/NA19238.chr22.bam
samtools index data/hapmap/NA19238.chr22.bam

```

```{}
samtools view -h ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/technical/other_exome_alignments/NA19240/exome_alignment/NA19240.mapped.solid.mosaik.YRI.exome.20111114.bam 22 | samtools view -bS - > data/hapmap/NA19240.chr22.bam
samtools index data/hapmap/NA19240.chr22.bam
```




# References

- [freebayes tutorial](http://clavius.bc.edu/~erik/CSHL-advanced-sequencing/freebayes-tutorial.html)
- [freebayes tutorial 2](https://libraries.io/github/benjaypunto/freebayes)
- [vcf files tutorial](https://faculty.washington.edu/browning/beagle/intro-to-vcf.html)
- [bedtools tutorial](http://quinlanlab.org/tutorials/bedtools/bedtools.html)


